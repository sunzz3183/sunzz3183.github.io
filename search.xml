<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>0/1分数规划学习笔记</title>
      <link href="/2023/09/01/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/01/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1分数规划学习笔记"><a href="#0-1分数规划学习笔记" class="headerlink" title="0&#x2F;1分数规划学习笔记"></a>0&#x2F;1分数规划学习笔记</h1><p>——by sunzz3183</p><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>$0&#x2F;1$ 分数规划是指，给定整数 $a_1,a_2,\cdots ,a_n,b_1,b_2,\cdots ,b_n$，求一组解 $x_i,x_i \in \left { 0,1 \right } $，使下面的式子最大化：</p><p>$$<br>\frac{\sum_{i&#x3D;1}^{n} a_i\times x_i}{\sum_{i&#x3D;1}^{n} b_i\times x_i}<br>$$</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><p>我们设一个值 $L$，假设存在一组解使得：</p><p>$$<br>\frac{\sum_{i&#x3D;1}^{n} a_i\times x_i}{\sum_{i&#x3D;1}^{n} b_i\times x_i} \geq L<br>$$</p><p>那么此时显然，最大值大于 $L$。</p><p>又因为</p><p>$$<br>\begin{aligned}<br>\frac{\sum_{i&#x3D;1}^{n} a_i\times x_i}{\sum_{i&#x3D;1}^{n} b_i\times x_i} &amp;\geq L\<br>\sum_{i&#x3D;1}^{n} a_i\times x_i&amp;\geq L\times \sum_{i&#x3D;1}^{n} b_i\times x_i\<br>\sum_{i&#x3D;1}^{n} a_i\times x_i-L\times \sum_{i&#x3D;1}^{n} b_i\times x_i&amp;\geq 0\<br>\sum_{i&#x3D;1}^{n} (a_i-L\times b_i)\times x_i&amp;\geq 0<br>\end{aligned}<br>$$</p><p>所以，</p><p>假设存在一组解使得：</p><p>$$ \sum_{i&#x3D;1}^{n} (a_i-L\times b_i)\times x_i\geq 0 $$</p><p>那么此时最大值大于等于 $L$。</p><p>同理</p><p>假设任意一组解使得：</p><p>$$ \sum_{i&#x3D;1}^{n} (a_i-L\times b_i)\times x_i&lt;0 $$</p><p>那么此时最大值小于 $L$。</p><p>又显然，$L$ 在取值时，解的存在满足单调性，所以显然可以二分。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>组合数学学习笔记</title>
      <link href="/2023/09/01/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/01/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="组合数学学习笔记"><a href="#组合数学学习笔记" class="headerlink" title="组合数学学习笔记"></a>组合数学学习笔记</h1><p>——by sunzz3183</p><hr><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>从 $n$ 个元素中选 $m$ 个元素的所有情况数（无顺序），记为</p><p>$$ C_{n}^{m} $$</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>$$ C_{n}^{m}&#x3D;\frac{n!}{m!(n-m)!} $$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li>直接求</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline int ksm(int a,int b)&#123;int t=1;for(;b;b&gt;&gt;=1,a=a*a%p)if(b&amp;1)t=t*a%p;return t%p;&#125;</span><br><span class="line">inline int C(int n,int m)&#123;</span><br><span class="line">    if(n&lt;m)return 0;</span><br><span class="line">    if(m&gt;n-m)m=n-m;</span><br><span class="line">    int a=1,b=1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">        a=a*(n-i+1)%p,b=b*i%p;</span><br><span class="line">    return a*ksm(b,p-2)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>预处理阶乘求</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int fac[N],inv[N];</span><br><span class="line">inline int ksm(int a,int b)&#123;int t=1;for(;b;b&gt;&gt;=1,a=a*a%mod)if(b&amp;1)t=t*a%mod;return t%mod;&#125;</span><br><span class="line">void init(int n)&#123;</span><br><span class="line">    fac[0]=inv[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        fac[i]=fac[i-1]*i%mod;</span><br><span class="line">    inv[n]=ksm(fac[n],mod-2);</span><br><span class="line">    for(int i=n;i&gt;=1;i--)</span><br><span class="line">        inv[i-1]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line">inline int C(int n,int m)&#123;</span><br><span class="line">    if(n&lt;m)return 0;</span><br><span class="line">    return fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>因为 </p><p>$$ C_{n}^m&#x3D;C_{n}^{n-m} $$</p><p>所以</p><p>$$ C_n^m&#x3D;C_{n-1}^{m-1}+C_{n-1}^{m} $$</p><h3 id="万用表"><a href="#万用表" class="headerlink" title="万用表"></a>万用表</h3><p>可以找到大部分组合数的规律</p><p><img src="https://pic.imgdb.cn/item/63f752e4f144a01007996ab1.png" alt="QQ截图20230218140945.png"></p><p>其中第 $n$ 行 $m$ 列为 $C_{n+m}^m$ 或 $C_{n+m}^n$</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>从 $n$ 个元素中选 $m$ 个元素的排列的所有情况数（有顺序），记为</p><p>$$ P_{n}^{m} $$</p><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><p>$$ P_{n}^{m}&#x3D;\frac{n!}{(n-m)!} $$</p><h2 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h2><p>$$ C_n^m \mod p&#x3D;C_{n&#x2F;p}^{m&#x2F;p} \times C_{n\bmod p}^{m\bmod p}\mod p$$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Lucas</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;<span class="keyword">return</span> m?<span class="built_in">Lucas</span>(n/p,m/p)*<span class="built_in">C</span>(n%p,m%p)%p:<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="卡特兰-Catalan-数"><a href="#卡特兰-Catalan-数" class="headerlink" title="卡特兰(Catalan)数"></a>卡特兰(Catalan)数</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>从 $(0,0)$ 不<strong>越过</strong>直线 $y&#x3D;x$ ，走到 $(n,n)$ 的方案个数。</p><p><img src="https://pic.imgdb.cn/item/63f8a611f144a0100780b5c9.png"></p><h3 id="式子"><a href="#式子" class="headerlink" title="式子"></a>式子</h3><p>设 $h(n)$ 为卡特兰数的第 $n$ 项。</p><p>令 $h(0)&#x3D;1,h(1)&#x3D;1$，卡特兰数满足递推式</p><p>$$ h(n)&#x3D; h(0)\times h(n-1)+h(1)\times h(n-2) + … + h(n-1)\times h(0) (n≥2) $$</p><p>另类递推式：</p><p>$$ h(n)&#x3D;h(n-1)\times (4\times n-2)&#x2F;(n+1) $$</p><p>$$ h(n+1)&#x3D;h(n)\times (4\times n + 2) &#x2F; (n + 2) $$</p><p>非递推：</p><p>$$ h(n)&#x3D;C_{2n}^n-C_{2n}^{n-1}&#x3D;\frac{C_{2n}^n}{n+1}&#x3D;\frac{(2n)!}{n!(n+1)!} $$</p><h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><p>在求一些走到 $(n,m)$ 的时候</p><p><img src="https://pic.imgdb.cn/item/63f8a62ef144a0100780dd52.png"></p><p>$$ f(n,m)&#x3D;C_{n+m}^n-C_{n+m}^{m-1}&#x3D;\frac{C_{n+m}^n\times (n-m+1)}{n+1}&#x3D;\frac{(n+m)!\times (n-m+1)}{m!(n+1)!} $$</p><h2 id="多重集组合数"><a href="#多重集组合数" class="headerlink" title="多重集组合数"></a>多重集组合数</h2><p>例题<a href="https://www.luogu.com.cn/problem/CF451E">Devu and Flowers</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定 $n(1\leq n \leq 20)$ 个数，每个数最多选 $a_i(1\leq a_i \leq 10^{12})$，一共选 $m(1\leq m \leq 10^{14})$ 个数，问方案数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然，当 $a_i\geq m$ 时，答案为</p><p>$$ C_{n+m-1}^{n-1} $$</p><p>那么如果不满足这种情况呢？</p><p>设第 $i$ 个数字为 $b_i$，此题可以转化为，从可重集 </p><p>$$ S&#x3D;\left { b_1\cdot a_1,b_2\cdot a_2,\cdots ,b_n\cdot a_n \right } $$</p><p>选 $m$ 个数的方案数。</p><p>根据容斥可得：</p><p>$$ C_{n+m-1}^{n-1}-\sum\limits_{i&#x3D;1}^n C_{n+m-a_i-2}^{n-1}+\sum\limits_{i&#x3D;1}^n \sum\limits_{j&#x3D;i+1}^n C_{n+m-a_i-a_j-3}^{n-1}-\cdots +(-1)^n C_{n+m-\sum\limits_{i&#x3D;1}^na_i-n-1}^{n-1} $$</p><p>实现时通过枚举二进制 $0\sim 2^n-1$ 来加减。</p><h2 id="球盒问题"><a href="#球盒问题" class="headerlink" title="球盒问题"></a>球盒问题</h2><h3 id="球不同，盒子不同，能有空可以重复放"><a href="#球不同，盒子不同，能有空可以重复放" class="headerlink" title="球不同，盒子不同，能有空可以重复放"></a>球不同，盒子不同，能有空可以重复放</h3><p>$$ m^n $$</p><h3 id="球不同，盒子不同，不能有空可以重复放"><a href="#球不同，盒子不同，不能有空可以重复放" class="headerlink" title="球不同，盒子不同，不能有空可以重复放"></a>球不同，盒子不同，不能有空可以重复放</h3><p>考虑容斥</p><p>$$ \sum_{i&#x3D;0}^m (-1)^{m-i} C_m^i i^n $$</p><h3 id="球不同，盒子同，不能有空可以重复放"><a href="#球不同，盒子同，不能有空可以重复放" class="headerlink" title="球不同，盒子同，不能有空可以重复放"></a>球不同，盒子同，不能有空可以重复放</h3><p>第二类斯特林数</p><p>$$ S(n,m)&#x3D;\frac{\sum_{i&#x3D;0}^m (-1)^{m-i} C_m^i i^n}{m!} $$</p><p>递推式：</p><p>$$ S(n,m)&#x3D;S(n-1,m-1)+S(n-1,m)\times m$$</p><h3 id="球不同，盒子同，能有空可以重复放"><a href="#球不同，盒子同，能有空可以重复放" class="headerlink" title="球不同，盒子同，能有空可以重复放"></a>球不同，盒子同，能有空可以重复放</h3><p>枚举几个空</p><p>第二类斯特林数前缀和</p><h3 id="球同，盒子不同，能-不能有空可以重复放"><a href="#球同，盒子不同，能-不能有空可以重复放" class="headerlink" title="球同，盒子不同，能&#x2F;不能有空可以重复放"></a>球同，盒子不同，能&#x2F;不能有空可以重复放</h3><p>隔板法</p><p>能：</p><p>$$ C_{n+m-1,m-1} $$</p><p>不能：</p><p>$$ C_{n-1,m-1} $$</p><h3 id="球同，盒子同，能为空可以重复放"><a href="#球同，盒子同，能为空可以重复放" class="headerlink" title="球同，盒子同，能为空可以重复放"></a>球同，盒子同，能为空可以重复放</h3><p>考虑 $DP$。</p><p>设 $f_{n,m}$ 为 $n$ 个球放进 $m$ 个盒子了的方案数。</p><p>则</p><p>$$ f_{n,m}&#x3D;f{n,m-1}+f{n-m,m} $$</p><p>解释：$f_{n,m-1}$ 为新加一个为空的格子，$f_{n-m,m}$ 为每个格子都加一个球。</p><h3 id="球同，盒子同，不能为空可以重复放"><a href="#球同，盒子同，不能为空可以重复放" class="headerlink" title="球同，盒子同，不能为空可以重复放"></a>球同，盒子同，不能为空可以重复放</h3><p>上一个问题的 $ f_{n-m,m} $。</p><p>由上一题得出差分式子 $ f_{n,m}-f{n,m-1} $。</p><h3 id="小思考"><a href="#小思考" class="headerlink" title="小思考"></a>小思考</h3><h4 id="盒子不同容斥，盒子同不容斥"><a href="#盒子不同容斥，盒子同不容斥" class="headerlink" title="盒子不同容斥，盒子同不容斥"></a>盒子不同容斥，盒子同不容斥</h4><p>由前面的全部式子可以看出，相同是不同的前缀和，而前缀和反演是差分，所以不容斥（有一点点吧）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯函数及其反演学习笔记</title>
      <link href="/2023/09/01/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/01/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="莫比乌斯函数及其反演学习笔记"><a href="#莫比乌斯函数及其反演学习笔记" class="headerlink" title="莫比乌斯函数及其反演学习笔记"></a>莫比乌斯函数及其反演学习笔记</h1><p>——by sunzz3183</p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$$ \mu (x)\equiv<br>\begin{cases}<br>1&amp;x&#x3D;1<br>\(-1)^k&amp;x&#x3D;p_1\cdot p_2\cdot \cdots\cdot p_k<br>\0&amp;otherwise<br>\end{cases} $$</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><ol><li>直接求</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mu</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">        <span class="keyword">if</span>(!(x%i))</span><br><span class="line">            <span class="keyword">if</span>(!(x/i%i))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> sum++;</span><br><span class="line">    <span class="keyword">return</span> sum&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>线性筛</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt,prime[M],phi[N],mu[N];</span><br><span class="line"><span class="type">bool</span> is_p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_p[i])prime[++cnt]=i,phi[i]=i<span class="number">-1</span>,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">            is_p[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))&#123;</span><br><span class="line">                phi[i*prime[j]]=phi[i]*prime[j];</span><br><span class="line">                mu[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（根据性质，很简单）</p><h2 id="反演"><a href="#反演" class="headerlink" title="反演"></a>反演</h2><h3 id="式子-1"><a href="#式子-1" class="headerlink" title="式子 1"></a>式子 1</h3><p>$$ \sum_{d \mid n} \mu(d)&#x3D;[n&#x3D;1] $$</p><h3 id="式子-2"><a href="#式子-2" class="headerlink" title="式子 2"></a>式子 2</h3><p>$$ [\operatorname{gcd}(i, j)&#x3D;1]&#x3D;\sum_{d \mid \gcd(i, j)} \mu(d) $$</p><p>由式子 1 得</p><h3 id="式子-3"><a href="#式子-3" class="headerlink" title="式子 3"></a>式子 3</h3><p>$$\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m}[\gcd(i,j)&#x3D;1]<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d|gcd(i,j)} \mu (d)<br>\&amp;&#x3D;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{d&#x3D;1}^{min(i,m)} \mu (d)\left \lfloor \frac{min(i,m)}{d}  \right \rfloor<br>\&amp;&#x3D;\sum\limits_{d&#x3D;1}^{min(n,m)} \mu (d)\left \lfloor \frac{n}{d}  \right \rfloor \left \lfloor \frac{m}{d}  \right \rfloor<br>\end{aligned}$$</p><h3 id="式子-4"><a href="#式子-4" class="headerlink" title="式子 4"></a>式子 4</h3><p>例题 <a href="https://www.luogu.com.cn/problem/P3455">[POI2007]ZAP-Queries</a></p><p>$$\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m}[\gcd(i,j)&#x3D;k]$$</p><p>我们可以转化和式子 3 一样的。</p><p>$$<br>\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m}[\gcd(i,j)&#x3D;k]<br>\&amp;&#x3D;\sum\limits_{i&#x3D;1}^{\left \lfloor \frac{n}{k}  \right \rfloor } \sum\limits_{j&#x3D;1}^{\left \lfloor \frac{m}{k}  \right \rfloor }[\gcd(i,j)&#x3D;1]<br>\&amp;&#x3D;\sum\limits_{i&#x3D;1}^{\left \lfloor \frac{n}{k}  \right \rfloor } \sum\limits_{j&#x3D;1}^{\left \lfloor \frac{m}{k}  \right \rfloor }\sum\limits_{d|gcd(i,j)} \mu (d)<br>\&amp;&#x3D;\sum\limits_{d&#x3D;1}^{\left \lfloor \frac{min(n,m)}{k} \right \rfloor } \mu (d)\left \lfloor \frac{n}{d\times k}  \right \rfloor \left \lfloor \frac{m}{d\times k}  \right \rfloor<br>\end{aligned}<br>$$</p><h3 id="式子-5"><a href="#式子-5" class="headerlink" title="式子 5"></a>式子 5</h3><p>$$ \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m}[\gcd(i,j)\leq x] $$</p><p>转化成式子 4。</p><p>$$<br>\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m}[\gcd(i,j)\leq x]<br>\&amp;&#x3D;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{k&#x3D;1}^{x}[\gcd(i,j)&#x3D;k]<br>\&amp;&#x3D;\sum\limits_{k&#x3D;1}^{x} \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m}[\gcd(i,j)&#x3D;k]<br>\&amp;&#x3D;\sum\limits_{k&#x3D;1}^{x} \sum\limits_{d&#x3D;1}^{\left \lfloor \frac{min(n,m)}{k} \right \rfloor } \mu (d)\left \lfloor \frac{n}{d\times k}  \right \rfloor \left \lfloor \frac{m}{d\times k}  \right \rfloor<br>\end{aligned}<br>$$</p><h3 id="求法总结"><a href="#求法总结" class="headerlink" title="求法总结"></a>求法总结</h3><p>线性筛 $O(n)$ 求，然后直接求的话也会是 $O(n)$，可以使用整数分块和前缀和来使时间优化到 $O(\sqrt{n})$。</p><h3 id="提高"><a href="#提高" class="headerlink" title="提高"></a><a href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">提高</a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>整数分块学习笔记</title>
      <link href="/2023/09/01/%E6%95%B4%E6%95%B0%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/01/%E6%95%B4%E6%95%B0%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="整数分块学习笔记"><a href="#整数分块学习笔记" class="headerlink" title="整数分块学习笔记"></a>整数分块学习笔记</h1><p>——by sunzz3183</p><hr><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>求</p><p>$$ \sum\limits_{i&#x3D;1}^{n}\left \lfloor \frac{n}{i}  \right \rfloor $$</p><p>正常求法：</p><p>直接枚举每个 $n$，时间复杂度为 $O(n)$。</p><p>可是，如果 $1\leq n \leq 10^8$ 呢？</p><p>所以，我们要用到分块的思想：<strong>整数分块</strong></p><h2 id="整数分块"><a href="#整数分块" class="headerlink" title="整数分块"></a>整数分块</h2><p>显然</p><p>$$ \exists 1\leq l\leq r \leq n,\left \lfloor \frac{n}{i}\right \rfloor &#x3D;\left \lfloor \frac{n}{j}\right \rfloor (l\leq i,j\leq r) $$</p><p>我们会浪费很多的时间。</p><p>那么，有多少段相等呢？</p><p>我们来看一张图</p><p><img src="https://pic.imgdb.cn/item/6407c03af144a0100785d06f.png"></p><p>显然，存在一个 $k$ 使得</p><p>$$ \left \lfloor \frac{n}{l} \right \rfloor &#x3D;k $$</p><p>并让</p><p>$$ r&#x3D;\left \lfloor \frac {n}{k }\right \rfloor $$</p><p>让</p><p>$$ \left \lfloor \frac{n}{i}\right \rfloor &#x3D;\left \lfloor \frac{n}{j}\right \rfloor (l\leq i,j\leq r) $$</p><p>而显然 $k$ 是由 $l$ 得到，$r$ 是由 $k$ 得到。</p><p>所以，我们去枚举 $l$，并让 $k,r$ 等于上面的东西。</p><p>而下一段区间的 $l$ 为 $r+1$。</p><p>每一段的值为 </p><p>$$ \left \lfloor \frac{n}{l} \right \rfloor (r-l+1) $$</p><p>时间复杂度 $O(\sqrt{n})$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">division_block</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">       r=n/(n/l),sum+=n/l*(r-l+<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高斯消元学习笔记</title>
      <link href="/2023/09/01/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/01/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="高斯消元学习笔记"><a href="#高斯消元学习笔记" class="headerlink" title="高斯消元学习笔记"></a>高斯消元学习笔记</h1><p>——by sunzz3183</p><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>高斯消元是一种求解线性方程组的方法。线性方程组就是 $m$ 个 $n$ 元一次方程。如：</p><p>$$<br>\left<br>{\begin{matrix}<br>x_1+2x_2-x_3&amp;&#x3D;-6<br>\2x_1+x_2-3x_3&amp;&#x3D;-9<br>\-x_1-x_2+2x_3&amp;&#x3D;7<br>\end{matrix}<br>\right.<br>$$</p><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>线性方程组可以写成一个由系数和常数组成的 $m$ 行 $n+1$ 列的增广矩阵。如：</p><p>$$<br>\begin{bmatrix}<br>  1&amp;  2&amp;  -1&amp; -6\<br>  2&amp;  1&amp;  -3&amp; -9\<br>  -1&amp;  -1&amp;  2&amp; 7<br>\end{bmatrix}<br>$$</p><p>增广矩阵有三个性质：</p><ol><li><p>任意交换矩阵的两行或两列，矩阵不变；</p></li><li><p>矩阵一行乘上一个非零数，矩阵不变；</p></li><li><p>把其中一行的若干倍加到另一行上，矩阵不变。</p></li></ol><p>那我们运用矩阵的各种性质，来将矩阵消成对角线上的元素为 $1$，并且除了第 $n+1$ 列其余元素均为 $0$ 的矩阵，这样我们就很容易的得出每个未知数的值：分别是从上到下第 $n+1$ 列的值（因为这时候第 $i$ 行的第 $i$ 个未知数系数都为 $1$）。</p><p>那么怎么消呢？</p><p><strong>高斯约旦消元法</strong></p><p>以上面的矩阵为例子：</p><p>$$<br>\begin{bmatrix}<br>  1&amp;  2&amp;  -1&amp; -6\<br>  2&amp;  1&amp;  -3&amp; -9\<br>  -1&amp;  -1&amp;  2&amp; 7<br>\end{bmatrix}<br>$$</p><p>明确我们的目的：把矩阵消成对角线为 $1$，除了第 $n+1$ 列其余元素都为 $0$。</p><p>若有一列全为 $0$，那么肯定有第 $i$ 行第 $i$ 列消不成 $1$，此时无解（少了一个方程，未知数就无法确定了）。</p><p>知道了这个，我们就可以对这个矩阵进行初步判定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,l;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>,t=i;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt;<span class="built_in">fabs</span>(a[t][i]))t=j;<span class="comment">//选绝对值最大的作用一会讲</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)<span class="built_in">swap</span>(a[i][j],a[t][j]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][i])&lt;eps)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>),<span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后利用性质 $2$ 让第 $i$ 行第 $i$ 列系数化为 $1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>,k=a[i][i];j&lt;=n+<span class="number">1</span>;j++)a[i][j]/=k;</span><br></pre></td></tr></table></figure><p>最后，利用性质 $3$ 将其他行的系数化为 $0$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    <span class="keyword">for</span>(l=<span class="number">1</span>,k=a[j][i];i!=j&amp;&amp;l&lt;=n+<span class="number">1</span>;l++)</span><br><span class="line">        a[j][l]-=k*a[i][l];</span><br></pre></td></tr></table></figure><p>然后就完成了！</p><p>最后第 $n+1$ 列就是答案了。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 0.000000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();<span class="type">int</span> x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||<span class="string">&#x27;9&#x27;</span>&lt;ch)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> f?x:-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n,t=<span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> a[N][N],k;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,l;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>,t=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt;<span class="built_in">fabs</span>(a[t][i]))t=j;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][i])&lt;eps)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>),<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)<span class="built_in">swap</span>(a[i][j],a[t][j]);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>,k=a[i][i];j&lt;=n+<span class="number">1</span>;j++)a[i][j]/=k;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(l=<span class="number">1</span>,k=a[j][i];i!=j&amp;&amp;l&lt;=n+<span class="number">1</span>;l++)</span><br><span class="line">                a[j][l]-=k*a[i][l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,a[i][n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>$Q$：为什么要选绝对值最大的数？</p><p>$A$：在消元过程中，为了避免出现除数为 $0$ 的情况，需要在每一行中找到一个绝对值最大的非零数作为主元，然后将该行与其他行进行消元。这样可以避免出现较大的误差，提高计算精度。<code>IEEE 754</code> 浮点数标准中数越接近 $0$ 越精确。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-模板"><a href="#1-模板" class="headerlink" title="1.模板"></a>1.模板</h3><p><a href="https://www.luogu.com.cn/problem/P3389">【模板】高斯消元法</a></p><p>数据较水，正常就能过。</p><h3 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2. 进阶"></a>2. 进阶</h3><p><a href="https://www.luogu.com.cn/problem/P2455">[SDOI2006]线性方程组</a></p><p>区别：数据更强，并加入了判断无解和多解。</p><p>判断方法：如果存在一行全为 $0$ 显然就是多解，如果存在一行系数全为 $0$ 常数不为 $0$，那么是无解。</p><p>注意：<strong>无解的优先级比多解高，多解的优先级比唯一解高</strong>。</p><h3 id="3-异或消元"><a href="#3-异或消元" class="headerlink" title="3. 异或消元"></a>3. 异或消元</h3><p>异或就是不进位的加法和减法，正常做就行。</p><p>优化：可以用一个数表示二进制数字。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();<span class="type">int</span> x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||<span class="string">&#x27;9&#x27;</span>&lt;ch)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> f?x:-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> T,n,t=<span class="number">1</span>,ans;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yudan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>,t=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[t])t=j;<span class="comment">//找主元最大的，实际上就是找a[j][i]==1</span></span><br><span class="line">        <span class="built_in">swap</span>(a[i],a[t]);</span><br><span class="line">        <span class="keyword">if</span>(!a[i])<span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(n-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        k=<span class="built_in">floor</span>(<span class="built_in">log2</span>(a[i]));</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;(a[i]&gt;&gt;k&amp;<span class="number">1</span>)&amp;&amp;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(j!=i&amp;&amp;(a[j]&gt;&gt;k&amp;<span class="number">1</span>))a[j]^=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>(),a[i]|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]^=<span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">while</span>(u&amp;&amp;v)</span><br><span class="line">            a[v]|=<span class="number">1</span>&lt;&lt;u,u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">yudan</span>();</span><br><span class="line">        <span class="keyword">if</span>(!ans)<span class="built_in">puts</span>(<span class="string">&quot;Oh,it&#x27;s impossible~!!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>同余问题学习笔记</title>
      <link href="/2023/08/09/%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/09/%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="同余问题学习笔记"><a href="#同余问题学习笔记" class="headerlink" title="同余问题学习笔记"></a>同余问题学习笔记</h1><p>   ——by sunzz3183</p><hr><h2 id="扩展欧几里得（exgcd）"><a href="#扩展欧几里得（exgcd）" class="headerlink" title="扩展欧几里得（exgcd）"></a>扩展欧几里得（exgcd）</h2><h3 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h3><p>对于两个正整数 $a,b$，存在两个<strong>整数</strong> $x,y$ 使得</p><p>$$ ax+by&#x3D;gcd(a,b) $$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>在欧几里得算法的最后一步，即 $b&#x3D;0$ 时，显然 $x&#x3D;1,y&#x3D;0$，使得 $a\times 1+0\times 0&#x3D;gcd(a,0)$。</p><p>若 $b&gt;0$ ,则，$gcd(a,b)&#x3D;gcd(b,a \bmod b)$。假设存在一对整数 $x,y$，满足 </p><p>$$bx+(a \bmod b)y&#x3D;gcd(b,a \bmod b)$$</p><p>因为 </p><p>$$bx+(a \bmod b)y&#x3D;bx+(a-b\left \lfloor \frac{a}{b}  \right \rfloor )y&#x3D;ay+b(x-\left \lfloor \frac{a}{b}  \right \rfloor y)$$</p><p>所以令 $x^{\prime}&#x3D;y,y^{\prime}&#x3D;x-\left \lfloor \frac{a}{b}  \right \rfloor y$，就得到了 $ax^{\prime}+by^{\prime}&#x3D;gcd(a,b)$</p><p>证毕</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通式"><a href="#通式" class="headerlink" title="通式"></a>通式</h3><p>则对于任意一个</p><p>$$ ax_0+by_0&#x3D;c $$</p><p>当 $gcd(a,b)|c$ 时，等式成立。</p><p>则此时 </p><p>$$x_0&#x3D;x\frac{c}{\gcd (a,b)} ,y_0&#x3D;y\frac{c}{\gcd (a,b)} $$</p><h3 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h3><p>设二元一次不定方程</p><p>$$ax+by&#x3D;c$$</p><p>有一组整数解 $x&#x3D;x_0,y&#x3D;y_0$，则一切整数解可以表示成</p><p>$$x&#x3D;x_0-\frac{bt}{\gcd (a,b)},y&#x3D;y0+\frac{at}{\gcd (a,b)}$$</p><p>其中 $t&#x3D;0,\pm 1,\pm 2,\pm 3,\cdots $</p><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>既然 $x0,y0$ 为整数解，当然满足 $ax_0+by_0&#x3D;c$，因此</p><p>$$ a(x_0-\frac{bt}{\gcd (a,b)})+b(y0+\frac{at}{\gcd (a,b)})&#x3D; ax_0+by_0&#x3D;c $$</p><p>设 $x^{\prime },y^{\prime }$ 为任意一组整数解，则有 $ax^{\prime }+by^{\prime }&#x3D;c$，减去 $ax_0+by_0&#x3D;c$，即得</p><p>$$ a(x^{\prime }-x_0)+b(y^{\prime }-y_0)&#x3D;0$$</p><p>$$ a(x^{\prime }-x_0)&#x3D;-b(y^{\prime }-y_0)$$</p><p>所以我们得到 </p><p>$$ a|(y^{\prime }-y_0)$$</p><p>即 </p><p>$$y^{\prime }&#x3D;y_0+at$$</p><p>将</p><p>$$ y^{\prime }&#x3D;y_0+at$$ </p><p>代入 </p><p>$$a(x^{\prime }-x_0)+b(y^{\prime }-y_0)&#x3D;0$$</p><p>即得 </p><p>$$x^{\prime }&#x3D;x_0-bt$$</p><p>因此 </p><p>$$ x^{\prime },y^{\prime }$$</p><p>可表示成 $x^{\prime }&#x3D;x_0-\frac{bt}{\gcd (a,b)},y^{\prime }&#x3D;y0+\frac{at}{\gcd (a,b)}$ 的形式</p><p>所以 </p><p>$$ x&#x3D;x_0-\frac{bt}{\gcd (a,b)},y&#x3D;y0+\frac{at}{\gcd (a,b)} $$ </p><p>为 $ax+by&#x3D;c$ 的一切整数解</p><p>证毕</p><h2 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h2><h3 id="命题-1"><a href="#命题-1" class="headerlink" title="命题"></a>命题</h3><p>已知同余式组</p><p>$$<br>\left{\begin{matrix}<br>x\equiv b_1\pmod{m_1} ,<br>\x\equiv b_2\pmod{m_2},<br>\\cdots ,<br>\x\equiv b_n\pmod{m_n}<br>\end{matrix}\right.<br>$$</p><p>其中 $b\in \mathbb{N} ,m\in \mathbb{N^* } ,m_i \perp m_j$</p><p>求 $x$</p><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>令</p><p>$$M&#x3D;\prod_{i&#x3D;1}^{n}m_i&#x3D;m_1M_1&#x3D;m_2M_2&#x3D;\cdots&#x3D;m_nM_n$$</p><p>则同时满足同余式组</p><p>$$<br>\left{\begin{matrix}<br>x\equiv b_1\pmod{m_1} ,<br>\x\equiv b_2\pmod{m_2},<br>\\cdots ,<br>\x\equiv b_n\pmod{m_n}<br>\end{matrix}\right.<br>$$</p><p>的正整数解是</p><p>$$ x\equiv \sum_{i&#x3D;1}^{n}b_iM_i^{\prime}M_i \pmod{M}$$</p><p>这里的 $M_i^{\prime}$ 是满足同余式</p><p>$$M_i^{\prime}M_i\equiv 1\pmod{m}$$</p><p>的正整数解</p><h3 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h3><p>因为 $m_i \perp m_j,M_i&#x3D;\frac{M}{m_i}$，所以 $m_i \perp M_i$，所以</p><p>$$gcd(m_i,M_i)&#x3D;gcd(m_j,M_j)&#x3D;1$$</p><p>由扩展欧几里得可得，存在两个整数 $M_i^{\prime},n_i$，使得</p><p>$$ M_i^{\prime}M_i+m_i+n_i&#x3D;1 $$</p><p>所以存在一个 $M_i^{\prime}$，使得</p><p>$$ M_i^{\prime}M_i \equiv 1 \pmod{m_i} $$</p><p>又由当 $i\ne j$时，则由 $m_i \perp m_j,M_j&#x3D;\frac{M}{m_j}$ 得到 $m_i|M_j$，所以</p><p>$$ b_jM_j^{\prime}M_j\equiv 0 \pmod{m_i} $$</p><p>所以</p><p>$$\sum_{i&#x3D;1}^{n}b_iM_i^{\prime}M_i \equiv b_iM_i^{\prime}M_i\equiv b_i \pmod{m_i}$$</p><p>设 $y$ 为同余式组的一个整数解，则得</p><p>$$<br>\left{\begin{matrix}<br>x\equiv y\pmod{m_1} ,<br>\x\equiv y\pmod{m_2},<br>\\cdots ,<br>\x\equiv y\pmod{m_n}<br>\end{matrix}\right.<br>$$</p><p>也就是</p><p>$$<br>\begin{matrix}<br>m_1|(x-y),<br>\m_2|(x-y),<br>\\cdots ,<br>\m_n|(x-y)<br>\end{matrix}<br>$$</p><p>又因为 $m_i \perp m_j$，所以有 $M|(x-y)$，也就是</p><p>$$x\equiv y \pmod{M}$$</p><p>所以</p><p>$$ x\equiv \sum_{i&#x3D;1}^{n}b_iM_i^{\prime}M_i \pmod{M}$$</p><p>是满足同余式组的唯一正整数解</p><p>证毕</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRT</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> B[],<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,a=<span class="number">0</span>,m,n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)n*=A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        m=n/A[i];</span><br><span class="line">        <span class="built_in">exgcd</span>(A[i],m,x,y);</span><br><span class="line">        (a+=y*m*B[i])%=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a+n)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展中国剩余定理（exCRT）"><a href="#扩展中国剩余定理（exCRT）" class="headerlink" title="扩展中国剩余定理（exCRT）"></a>扩展中国剩余定理（exCRT）</h2><h3 id="命题-2"><a href="#命题-2" class="headerlink" title="命题"></a>命题</h3><p>已知同余式组</p><p>$$<br>\left{\begin{matrix}<br>X\equiv b_1\pmod{m_1} ,<br>\X\equiv b_2\pmod{m_2},<br>\\cdots ,<br>\X\equiv b_n\pmod{m_n}<br>\end{matrix}\right.<br>$$</p><p>其中 $b\in \mathbb{N} ,m\in \mathbb{N^* }$</p><p>求 $X$</p><p>与 $CRT$ 不同的是，这个 $m_i,m_j$，不一定两两互质。</p><h3 id="求法-1"><a href="#求法-1" class="headerlink" title="求法"></a>求法</h3><p>（建议配合代码食用）</p><p>考虑合并</p><p>$$<br>\left{\begin{matrix}<br>X\equiv b_1\pmod{m_1} ,<br>\X\equiv b_2\pmod{m_2}<br>\end{matrix}\right.<br>$$<br>可以写成</p><p>$$<br>\left{\begin{matrix}<br>X&#x3D;b_1+m_1x ,<br>\X&#x3D;b_2+m_2y<br>\end{matrix}\right.<br>$$</p><p>所以</p><p>$$b_1+m_1x&#x3D;b_2+m_2y$$</p><p>整理，得</p><p>$$m_1x+m_2(-y)&#x3D;b_2-b_1$$</p><p>通过 $exgcd$ 可以得到一组解 $x_0,y_0$</p><p>所以</p><p>$$m_1x_0\frac{b_2-b_1}{\gcd(m_1,m_2)}+m_2y_0\frac{b_2-b_1}{\gcd(m_1,m_2)}&#x3D;\gcd(m_1,m_2)\frac{b_2-b_1}{\gcd(m_1,m_2)}&#x3D;b_2-b_1$$</p><p>因为 $X&#x3D;m_1x+b_1$，现在要最小化 $X$，也就是最小化 $x$，即最小化 $x&#x3D;x_0\frac{b_2-b_1}{\gcd(m_1,m_2)}$</p><p>我们假设 $b_2,m_2$，为已经算出的前 $k$ 对数的答案</p><p>于是就可以将这两个同余方程合并为</p><p>$$X\equiv m_1x+b_1 \pmod {lcm(m_1,m_2)}$$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exCRT</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,a=A[<span class="number">1</span>],ans=B[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++)&#123;</span><br><span class="line">    <span class="type">int</span> b=A[i],c=((B[i]-ans)%b+b)%b,d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">    <span class="keyword">if</span>(c%d)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    x=(__int128)x*(__int128)c/(__int128)d%(b/d);</span><br><span class="line">    ans+=a*x;</span><br><span class="line">    a=a/d*b;</span><br><span class="line">    ans=(ans%a+a)%a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans%a+a)%a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数及欧拉定理&amp;逆元学习笔记</title>
      <link href="/2023/08/08/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86&amp;%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/08/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86&amp;%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉函数及欧拉定理-逆元学习笔记"><a href="#欧拉函数及欧拉定理-逆元学习笔记" class="headerlink" title="欧拉函数及欧拉定理&amp;逆元学习笔记"></a>欧拉函数及欧拉定理&amp;逆元学习笔记</h1><p>   ——by sunzz3183</p><hr><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$$\varphi (n)&#x3D;\sum\limits_{i&#x3D;1}^{n} [\gcd(n,i)&#x3D;1]$$</p><p>根据容斥可得</p><p>$$ \varphi(n)&#x3D;n\prod_{i&#x3D;1}^{k}(1-\frac{1}{p_i}) $$</p><p>所以可得以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line"><span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">res=res/i*(i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(!(x%i))x/=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>)res=res/x*(x<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>$$ \varphi(n)&#x3D;n\prod_{i&#x3D;1}^{k}(1-\frac{1}{p_i}) $$</p><p>所以：</p><ol><li>当 $n$ 为质数的时候 $\varphi (n)&#x3D;n-1$</li></ol><ul><li>设 $d&#x3D;\frac{n}{p}$ 其中 $p$为 $n$ 的最小质因子。</li></ul><ol start="2"><li><p>当 $p$ 是 $d$ 的某个质因子时，则 $\varphi (n)&#x3D;\varphi (d)\times p$</p></li><li><p>当 $p$ 与 $d$ 互质时，$\varphi (n)&#x3D;\varphi (d)\times \varphi (p)$</p></li></ol><p>所以，欧拉函数为积性函数（当 $x\perp y$ 时, $\varphi (xy)&#x3D;\varphi (x)\times \varphi (y)$）</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt,prime[M],phi[N],mu[N];</span><br><span class="line"><span class="type">bool</span> is_p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>]=mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_p[i])prime[++cnt]=i,phi[i]=i<span class="number">-1</span>,mu[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">is_p[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!(i%prime[j]))&#123;</span><br><span class="line">phi[i*prime[j]]=phi[i]*prime[j];</span><br><span class="line">mu[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">mu[i*prime[j]]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要公式："><a href="#重要公式：" class="headerlink" title="重要公式："></a>重要公式：</h3><p>$(1)$</p><p>$$ \sum\limits_{d|n} \varphi (d)&#x3D;n $$</p><p>证明：</p><p>设 $f(n)&#x3D;\sum\limits_{d|n} \varphi (d)$</p><p>由筛法的原理1,2可知</p><p>$$ \varphi (p^k)&#x3D;\varphi (p)\times p^{k-1}&#x3D;(p-1)\times p^{k-1}&#x3D;p^k-p^{k-1}$$</p><p>对于</p><p>$$ \sum\limits_{d|p^k} \varphi (d) $$</p><p>显然，$d&#x3D;\left {   p^0,p^1,p^2,…,p^k\right }$ 。那么有</p><p>$$\begin{aligned}<br>\&amp;&#x3D;\sum\limits_{i&#x3D;0}^k \varphi (p^i)<br>\&amp;&#x3D;(\sum\limits_{i&#x3D;1}^k p^i-p^{i-1})+1<br>\&amp;&#x3D;p^k-p^{k-1}+p^{k-1}-p^{k-2}+…+p-1+1<br>\&amp;&#x3D;p^k<br>\end{aligned}$$</p><p>$\therefore f(p^k)&#x3D;p^k$</p><p>$\because f(ab)&#x3D;\sum\limits_{d|ab} \varphi (d)&#x3D;(\sum\limits_{d|a} \varphi (d)) \times (\sum\limits_{d|b} \varphi (d))&#x3D;f(a)\times f(b)$</p><p>$\therefore f(n)$为积性函数。</p><p>$$\begin{aligned}<br>\&amp;\therefore f(n)<br>\&amp;&#x3D;f(p_1^{c_1}\times p_2^{c_2}\times p_3^{c_3}\times …\times p_k^{c_k})<br>\&amp;&#x3D;f(p_1^{c_1})\times f(p_2^{c_2})\times f(p_3^{c_3})\times …\times f(p_k^{c_k})<br>\&amp;&#x3D; p_1^{c_1}\times p_2^{c_2}\times p_3^{c_3}\times …\times p_k^{c_k}<br>\&amp;&#x3D;n<br>\end{aligned}$$</p><p>$(2)$</p><p>$$\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{n} [\gcd(i,j)&#x3D;1]<br>\&amp;&#x3D;\sum\limits_{i&#x3D;1}^{n}(2\sum\limits_{j&#x3D;1}^{i}[\gcd (i,j)&#x3D;1])-1<br>\&amp;&#x3D;2 \sum\limits_{i&#x3D;1}^{n}\varphi (i)-1<br>\end{aligned}$$</p><p>可以使用前缀和，使得 $O(1)$ 查询。</p><p>$(2.5)$</p><p>$$\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \gcd(i,j)<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d|gcd(i,j)} \varphi (d)<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d|i,d|j} \varphi (d)<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d&#x3D;1}^{min(n,m)} \varphi (d)[d|i][d|j]<br>\&amp;&#x3D;\sum\limits_{d&#x3D;1}^{min(n,m)} \varphi (d) \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} [d|i][d|j]<br>\&amp;&#x3D;\sum\limits_{d&#x3D;1}^{min(n,m)} \varphi (d) \left \lfloor \frac{n}{d}  \right \rfloor \left \lfloor \frac{m}{d}  \right \rfloor<br>\end{aligned}$$</p><p>$(3)$</p><p>莫比乌斯反演（拓展）</p><p>$$\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m}[\gcd(i,j)&#x3D;&#x3D;1]<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d|gcd(i,j)} \mu (d)<br>\&amp;&#x3D;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{d&#x3D;1}^{min(i,m)} \mu (d)\left \lfloor \frac{min(i,m)}{d}  \right \rfloor<br>\&amp;&#x3D;\sum\limits_{d&#x3D;1}^{min(n,m)} \mu (d)\left \lfloor \frac{n}{d}  \right \rfloor \left \lfloor \frac{m}{d}  \right \rfloor<br>\end{aligned}$$</p><h2 id="费马小定理-欧拉定理-扩展欧拉定理"><a href="#费马小定理-欧拉定理-扩展欧拉定理" class="headerlink" title="费马小定理&amp;欧拉定理&amp;扩展欧拉定理"></a>费马小定理&amp;欧拉定理&amp;扩展欧拉定理</h2><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>如果</p><p>$$ d|(a-b) $$</p><p>则我们称</p><p>$$ a\equiv b\pmod{d}$$</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>1.反身性：$a\equiv a \pmod{m}$；</p><p>2.对称性：若 $a\equiv b \pmod{m}$，则 $b\equiv a \pmod{m}$；</p><p>3.传递性：若 $a\equiv b \pmod{m}$，$b\equiv c \pmod{m}$，则 $a\equiv c \pmod{m}$；</p><p>4.同余式相加：若 $a\equiv b \pmod{m}$，$c\equiv d \pmod{m}$，则 $a\pm c\equiv b\pm d \pmod{m}$；</p><p>5.同余式相乘：若 $a\equiv b \pmod{m}$，$c\equiv d \pmod{m}$，则$ac\equiv bd \pmod{m}$。</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>对于一个整数 $a$ 和 质数 $p$，如果满足</p><p>$$a\perp p$$</p><p>则符合</p><p>$$a^{p-1}\equiv 1 \pmod{p}$$</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>费马小定理的广义。</p><p>对于两个整数 $a$ 和 $m$，如果满足</p><p>$$a\perp m$$</p><p>则符合</p><p>$$a^{\varphi(m)}\equiv 1\pmod{m}$$</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>若</p><p>$$ ab\equiv 1\bmod m $$</p><p>则 </p><p>$b$ 为 $a$ 在 $\bmod m$ 意义下的逆元，同时，$a$ 也为 $b$ 在 $\bmod m$ 意义下的逆元。</p><p>任意整数 $a$ 在 $\bmod m$ 意义下的逆元记为 $inv(a,m)$。</p><p>显然，逆元就是在 $\bmod$ 某个数意义下的倒数，即</p><p>$$ inv(a,m)&#x3D;a^{-1} \bmod m$$</p><h4 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h4><ol><li>费马小定理求法（$p\in Prime,a\perp p$）</li></ol><p>$$\begin{aligned}<br>\&amp;\because a^{p-1}\equiv 1 \pmod{p}<br>\&amp;\therefore a^{p-2}&#x3D;\frac {1}{a}\pmod{p}<br>\&amp;\therefore inv(a,p)&#x3D;a^{p-2}\pmod{p}<br>\end{aligned}$$</p><ol start="2"><li>欧拉定理求法（$a\perp m$）</li></ol><p>$$\begin{aligned}<br>\&amp;\because a^{\varphi(m)}\equiv 1 \pmod{m}<br>\&amp;\therefore a^{\varphi(m)-1}&#x3D;\frac {1}{a}\pmod{m}<br>\&amp;\therefore inv(a,p)&#x3D;a^{\varphi(m)-1}\pmod{m}<br>\end{aligned}$$</p><ol start="3"><li>线性求逆元（$p\in Prime,a\perp p$）</li></ol><p>对于所有的 $i&lt;p$，有一种线性求逆元（$i^{-1}$）的方法。</p><p>因为 $i&lt;p$，所以可以用 $i$ 表示 $p$，即</p><p>$$ p&#x3D;ki+b $$</p><p>即</p><p>$$ ik+b \equiv 0 \pmod{p} $$</p><p>等式两边同乘 $i^{-1}$，得</p><p>$$ k+bi^{-1} \equiv 0 \pmod{p} $$</p><p>移项，分离处 $i^{-1}$，得</p><p>$$ i^{-1} \equiv -kb^{-1} \pmod{p} $$</p><p>又</p><p>$$ \begin{aligned}<br>\&amp;\because k&#x3D;\left \lfloor p&#x2F;i \right \rfloor,b&#x3D;p\bmod i<br>\&amp;\therefore i^{-1} \equiv -(p&#x2F;i)(p\bmod i)^{-1} \pmod{p}<br>\&amp;\therefore i^{-1} \equiv (p-p&#x2F;i)(p\bmod i)^{-1} \pmod{p}<br>\end{aligned} $$</p><p>因为 $(p\bmod i)^{-1}$ 已经处理好了</p><p>所以可以线性处理</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br></pre></td></tr></table></figure><ol start="4"><li>线性求阶乘逆元</li></ol><p>可以在组合数问题上发挥作用</p><p>显然</p><p>$$\frac{1}{(n-1)!}&#x3D;n\cdot \frac{1}{n!}$$</p><p>所以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">inv[n]=<span class="built_in">ksm</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br></pre></td></tr></table></figure><h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>$$a^b\equiv<br>\begin{cases}<br>a^{b\mod{\varphi(m)}}&amp;a\perp m<br>\a^b&amp;\neg a\perp m,b&lt;\varphi (m)<br>\a^{b\mod{\varphi (m)} +\varphi (m)}&amp;\neg a\perp m,b\geq\varphi(m)<br>\end{cases}<br>\mod{m}$$</p><p>互质可以不要</p><p>$$ a^b \equiv \begin{cases} a^b&amp;b&lt;\varphi (m)\a^{b\mod{\varphi (m)} +\varphi (m)}&amp;b\geq\varphi (m)\end{cases}\mod{m}$$</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
