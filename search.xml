<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>同余问题学习笔记</title>
      <link href="/2023/08/09/%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/09/%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="同余问题学习笔记"><a href="#同余问题学习笔记" class="headerlink" title="同余问题学习笔记"></a>同余问题学习笔记</h1><p>   ——by sunzz3183</p><hr><h2 id="扩展欧几里得（exgcd）"><a href="#扩展欧几里得（exgcd）" class="headerlink" title="扩展欧几里得（exgcd）"></a>扩展欧几里得（exgcd）</h2><h3 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h3><p>对于两个正整数 $a,b$，存在两个<strong>整数</strong> $x,y$ 使得</p><p>$$ ax+by&#x3D;gcd(a,b) $$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>在欧几里得算法的最后一步，即 $b&#x3D;0$ 时，显然 $x&#x3D;1,y&#x3D;0$，使得 $a\times 1+0\times 0&#x3D;gcd(a,0)$。</p><p>若 $b&gt;0$ ,则，$gcd(a,b)&#x3D;gcd(b,a \bmod b)$。假设存在一对整数 $x,y$，满足 </p><p>$$bx+(a \bmod b)y&#x3D;gcd(b,a \bmod b)$$</p><p>因为 </p><p>$$bx+(a \bmod b)y&#x3D;bx+(a-b\left \lfloor \frac{a}{b}  \right \rfloor )y&#x3D;ay+b(x-\left \lfloor \frac{a}{b}  \right \rfloor y)$$</p><p>所以令 $x^{\prime}&#x3D;y,y^{\prime}&#x3D;x-\left \lfloor \frac{a}{b}  \right \rfloor y$，就得到了 $ax^{\prime}+by^{\prime}&#x3D;gcd(a,b)$</p><p>证毕</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通式"><a href="#通式" class="headerlink" title="通式"></a>通式</h3><p>则对于任意一个</p><p>$$ ax_0+by_0&#x3D;c $$</p><p>当 $gcd(a,b)|c$ 时，等式成立。</p><p>则此时 </p><p>$$x_0&#x3D;x\frac{c}{\gcd (a,b)} ,y_0&#x3D;y\frac{c}{\gcd (a,b)} $$</p><h3 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h3><p>设二元一次不定方程</p><p>$$ax+by&#x3D;c$$</p><p>有一组整数解 $x&#x3D;x_0,y&#x3D;y_0$，则一切整数解可以表示成</p><p>$$x&#x3D;x_0-\frac{bt}{\gcd (a,b)},y&#x3D;y0+\frac{at}{\gcd (a,b)}$$</p><p>其中 $t&#x3D;0,\pm 1,\pm 2,\pm 3,\cdots $</p><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>既然 $x0,y0$ 为整数解，当然满足 $ax_0+by_0&#x3D;c$，因此</p><p>$$ a(x_0-\frac{bt}{\gcd (a,b)})+b(y0+\frac{at}{\gcd (a,b)})&#x3D; ax_0+by_0&#x3D;c $$</p><p>设 $x^{\prime },y^{\prime }$ 为任意一组整数解，则有 $ax^{\prime }+by^{\prime }&#x3D;c$，减去 $ax_0+by_0&#x3D;c$，即得</p><p>$$ a(x^{\prime }-x_0)+b(y^{\prime }-y_0)&#x3D;0$$</p><p>$$ a(x^{\prime }-x_0)&#x3D;-b(y^{\prime }-y_0)$$</p><p>所以我们得到 </p><p>$$ a|(y^{\prime }-y_0)$$</p><p>即 </p><p>$$y^{\prime }&#x3D;y_0+at$$</p><p>将</p><p>$$ y^{\prime }&#x3D;y_0+at$$ </p><p>代入 </p><p>$$a(x^{\prime }-x_0)+b(y^{\prime }-y_0)&#x3D;0$$</p><p>即得 </p><p>$$x^{\prime }&#x3D;x_0-bt$$</p><p>因此 </p><p>$$ x^{\prime },y^{\prime }$$</p><p>可表示成 $x^{\prime }&#x3D;x_0-\frac{bt}{\gcd (a,b)},y^{\prime }&#x3D;y0+\frac{at}{\gcd (a,b)}$ 的形式</p><p>所以 </p><p>$$ x&#x3D;x_0-\frac{bt}{\gcd (a,b)},y&#x3D;y0+\frac{at}{\gcd (a,b)} $$ </p><p>为 $ax+by&#x3D;c$ 的一切整数解</p><p>证毕</p><h2 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h2><h3 id="命题-1"><a href="#命题-1" class="headerlink" title="命题"></a>命题</h3><p>已知同余式组</p><p>$$<br>\left{\begin{matrix}<br>x\equiv b_1\pmod{m_1} ,<br>\x\equiv b_2\pmod{m_2},<br>\\cdots ,<br>\x\equiv b_n\pmod{m_n}<br>\end{matrix}\right.<br>$$</p><p>其中 $b\in \mathbb{N} ,m\in \mathbb{N^* } ,m_i \perp m_j$</p><p>求 $x$</p><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>令</p><p>$$M&#x3D;\prod_{i&#x3D;1}^{n}m_i&#x3D;m_1M_1&#x3D;m_2M_2&#x3D;\cdots&#x3D;m_nM_n$$</p><p>则同时满足同余式组</p><p>$$<br>\left{\begin{matrix}<br>x\equiv b_1\pmod{m_1} ,<br>\x\equiv b_2\pmod{m_2},<br>\\cdots ,<br>\x\equiv b_n\pmod{m_n}<br>\end{matrix}\right.<br>$$</p><p>的正整数解是</p><p>$$ x\equiv \sum_{i&#x3D;1}^{n}b_iM_i^{\prime}M_i \pmod{M}$$</p><p>这里的 $M_i^{\prime}$ 是满足同余式</p><p>$$M_i^{\prime}M_i\equiv 1\pmod{m}$$</p><p>的正整数解</p><h3 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h3><p>因为 $m_i \perp m_j,M_i&#x3D;\frac{M}{m_i}$，所以 $m_i \perp M_i$，所以</p><p>$$gcd(m_i,M_i)&#x3D;gcd(m_j,M_j)&#x3D;1$$</p><p>由扩展欧几里得可得，存在两个整数 $M_i^{\prime},n_i$，使得</p><p>$$ M_i^{\prime}M_i+m_i+n_i&#x3D;1 $$</p><p>所以存在一个 $M_i^{\prime}$，使得</p><p>$$ M_i^{\prime}M_i \equiv 1 \pmod{m_i} $$</p><p>又由当 $i\ne j$时，则由 $m_i \perp m_j,M_j&#x3D;\frac{M}{m_j}$ 得到 $m_i|M_j$，所以</p><p>$$ b_jM_j^{\prime}M_j\equiv 0 \pmod{m_i} $$</p><p>所以</p><p>$$\sum_{i&#x3D;1}^{n}b_iM_i^{\prime}M_i \equiv b_iM_i^{\prime}M_i\equiv b_i \pmod{m_i}$$</p><p>设 $y$ 为同余式组的一个整数解，则得</p><p>$$<br>\left{\begin{matrix}<br>x\equiv y\pmod{m_1} ,<br>\x\equiv y\pmod{m_2},<br>\\cdots ,<br>\x\equiv y\pmod{m_n}<br>\end{matrix}\right.<br>$$</p><p>也就是</p><p>$$<br>\begin{matrix}<br>m_1|(x-y),<br>\m_2|(x-y),<br>\\cdots ,<br>\m_n|(x-y)<br>\end{matrix}<br>$$</p><p>又因为 $m_i \perp m_j$，所以有 $M|(x-y)$，也就是</p><p>$$x\equiv y \pmod{M}$$</p><p>所以</p><p>$$ x\equiv \sum_{i&#x3D;1}^{n}b_iM_i^{\prime}M_i \pmod{M}$$</p><p>是满足同余式组的唯一正整数解</p><p>证毕</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRT</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> B[],<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,a=<span class="number">0</span>,m,n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)n*=A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        m=n/A[i];</span><br><span class="line">        <span class="built_in">exgcd</span>(A[i],m,x,y);</span><br><span class="line">        (a+=y*m*B[i])%=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a+n)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展中国剩余定理（exCRT）"><a href="#扩展中国剩余定理（exCRT）" class="headerlink" title="扩展中国剩余定理（exCRT）"></a>扩展中国剩余定理（exCRT）</h2><h3 id="命题-2"><a href="#命题-2" class="headerlink" title="命题"></a>命题</h3><p>已知同余式组</p><p>$$<br>\left{\begin{matrix}<br>X\equiv b_1\pmod{m_1} ,<br>\X\equiv b_2\pmod{m_2},<br>\\cdots ,<br>\X\equiv b_n\pmod{m_n}<br>\end{matrix}\right.<br>$$</p><p>其中 $b\in \mathbb{N} ,m\in \mathbb{N^* }$</p><p>求 $X$</p><p>与 $CRT$ 不同的是，这个 $m_i,m_j$，不一定两两互质。</p><h3 id="求法-1"><a href="#求法-1" class="headerlink" title="求法"></a>求法</h3><p>（建议配合代码食用）</p><p>考虑合并</p><p>$$<br>\left{\begin{matrix}<br>X\equiv b_1\pmod{m_1} ,<br>\X\equiv b_2\pmod{m_2}<br>\end{matrix}\right.<br>$$<br>可以写成</p><p>$$<br>\left{\begin{matrix}<br>X&#x3D;b_1+m_1x ,<br>\X&#x3D;b_2+m_2y<br>\end{matrix}\right.<br>$$</p><p>所以</p><p>$$b_1+m_1x&#x3D;b_2+m_2y$$</p><p>整理，得</p><p>$$m_1x+m_2(-y)&#x3D;b_2-b_1$$</p><p>通过 $exgcd$ 可以得到一组解 $x_0,y_0$</p><p>所以</p><p>$$m_1x_0\frac{b_2-b_1}{\gcd(m_1,m_2)}+m_2y_0\frac{b_2-b_1}{\gcd(m_1,m_2)}&#x3D;\gcd(m_1,m_2)\frac{b_2-b_1}{\gcd(m_1,m_2)}&#x3D;b_2-b_1$$</p><p>因为 $X&#x3D;m_1x+b_1$，现在要最小化 $X$，也就是最小化 $x$，即最小化 $x&#x3D;x_0\frac{b_2-b_1}{\gcd(m_1,m_2)}$</p><p>我们假设 $b_2,m_2$，为已经算出的前 $k$ 对数的答案</p><p>于是就可以将这两个同余方程合并为</p><p>$$X\equiv m_1x+b_1 \pmod {lcm(m_1,m_2)}$$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exCRT</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,a=A[<span class="number">1</span>],ans=B[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++)&#123;</span><br><span class="line">    <span class="type">int</span> b=A[i],c=((B[i]-ans)%b+b)%b,d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">    <span class="keyword">if</span>(c%d)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    x=(__int128)x*(__int128)c/(__int128)d%(b/d);</span><br><span class="line">    ans+=a*x;</span><br><span class="line">    a=a/d*b;</span><br><span class="line">    ans=(ans%a+a)%a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans%a+a)%a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数及欧拉定理&amp;逆元学习笔记</title>
      <link href="/2023/08/08/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86&amp;%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/08/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86&amp;%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉函数及欧拉定理-逆元学习笔记"><a href="#欧拉函数及欧拉定理-逆元学习笔记" class="headerlink" title="欧拉函数及欧拉定理&amp;逆元学习笔记"></a>欧拉函数及欧拉定理&amp;逆元学习笔记</h1><p>   ——by sunzz3183</p><hr><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$$\varphi (n)&#x3D;\sum\limits_{i&#x3D;1}^{n} [\gcd(n,i)&#x3D;1]$$</p><p>根据容斥可得</p><p>$$ \varphi(n)&#x3D;n\prod_{i&#x3D;1}^{k}(1-\frac{1}{p_i}) $$</p><p>所以可得以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line"><span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">res=res/i*(i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(!(x%i))x/=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>)res=res/x*(x<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>$$ \varphi(n)&#x3D;n\prod_{i&#x3D;1}^{k}(1-\frac{1}{p_i}) $$</p><p>所以：</p><ol><li>当 $n$ 为质数的时候 $\varphi (n)&#x3D;n-1$</li></ol><ul><li>设 $d&#x3D;\frac{n}{p}$ 其中 $p$为 $n$ 的最小质因子。</li></ul><ol start="2"><li><p>当 $p$ 是 $d$ 的某个质因子时，则 $\varphi (n)&#x3D;\varphi (d)\times p$</p></li><li><p>当 $p$ 与 $d$ 互质时，$\varphi (n)&#x3D;\varphi (d)\times \varphi (p)$</p></li></ol><p>所以，欧拉函数为积性函数（当 $x\perp y$ 时, $\varphi (xy)&#x3D;\varphi (x)\times \varphi (y)$）</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt,prime[M],phi[N],mu[N];</span><br><span class="line"><span class="type">bool</span> is_p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>]=mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_p[i])prime[++cnt]=i,phi[i]=i<span class="number">-1</span>,mu[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">is_p[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!(i%prime[j]))&#123;</span><br><span class="line">phi[i*prime[j]]=phi[i]*prime[j];</span><br><span class="line">mu[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">mu[i*prime[j]]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要公式："><a href="#重要公式：" class="headerlink" title="重要公式："></a>重要公式：</h3><p>$(1)$</p><p>$$ \sum\limits_{d|n} \varphi (d)&#x3D;n $$</p><p>证明：</p><p>设 $f(n)&#x3D;\sum\limits_{d|n} \varphi (d)$</p><p>由筛法的原理1,2可知</p><p>$$ \varphi (p^k)&#x3D;\varphi (p)\times p^{k-1}&#x3D;(p-1)\times p^{k-1}&#x3D;p^k-p^{k-1}$$</p><p>对于</p><p>$$ \sum\limits_{d|p^k} \varphi (d) $$</p><p>显然，$d&#x3D;\left {   p^0,p^1,p^2,…,p^k\right }$ 。那么有</p><p>$$\begin{aligned}<br>\&amp;&#x3D;\sum\limits_{i&#x3D;0}^k \varphi (p^i)<br>\&amp;&#x3D;(\sum\limits_{i&#x3D;1}^k p^i-p^{i-1})+1<br>\&amp;&#x3D;p^k-p^{k-1}+p^{k-1}-p^{k-2}+…+p-1+1<br>\&amp;&#x3D;p^k<br>\end{aligned}$$</p><p>$\therefore f(p^k)&#x3D;p^k$</p><p>$\because f(ab)&#x3D;\sum\limits_{d|ab} \varphi (d)&#x3D;(\sum\limits_{d|a} \varphi (d)) \times (\sum\limits_{d|b} \varphi (d))&#x3D;f(a)\times f(b)$</p><p>$\therefore f(n)$为积性函数。</p><p>$$\begin{aligned}<br>\&amp;\therefore f(n)<br>\&amp;&#x3D;f(p_1^{c_1}\times p_2^{c_2}\times p_3^{c_3}\times …\times p_k^{c_k})<br>\&amp;&#x3D;f(p_1^{c_1})\times f(p_2^{c_2})\times f(p_3^{c_3})\times …\times f(p_k^{c_k})<br>\&amp;&#x3D; p_1^{c_1}\times p_2^{c_2}\times p_3^{c_3}\times …\times p_k^{c_k}<br>\&amp;&#x3D;n<br>\end{aligned}$$</p><p>$(2)$</p><p>$$\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{n} [\gcd(i,j)&#x3D;1]<br>\&amp;&#x3D;\sum\limits_{i&#x3D;1}^{n}(2\sum\limits_{j&#x3D;1}^{i}[\gcd (i,j)&#x3D;1])-1<br>\&amp;&#x3D;2 \sum\limits_{i&#x3D;1}^{n}\varphi (i)-1<br>\end{aligned}$$</p><p>可以使用前缀和，使得 $O(1)$ 查询。</p><p>$(2.5)$</p><p>$$\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \gcd(i,j)<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d|gcd(i,j)} \varphi (d)<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d|i,d|j} \varphi (d)<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d&#x3D;1}^{min(n,m)} \varphi (d)[d|i][d|j]<br>\&amp;&#x3D;\sum\limits_{d&#x3D;1}^{min(n,m)} \varphi (d) \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} [d|i][d|j]<br>\&amp;&#x3D;\sum\limits_{d&#x3D;1}^{min(n,m)} \varphi (d) \left \lfloor \frac{n}{d}  \right \rfloor \left \lfloor \frac{m}{d}  \right \rfloor<br>\end{aligned}$$</p><p>$(3)$</p><p>莫比乌斯反演（拓展）</p><p>$$\begin{aligned}<br>\&amp;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m}[\gcd(i,j)&#x3D;&#x3D;1]<br>\&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n} \sum\limits_{j&#x3D;1}^{m} \sum\limits_{d|gcd(i,j)} \mu (d)<br>\&amp;&#x3D;\sum\limits_{i&#x3D;1}^{n} \sum\limits_{d&#x3D;1}^{min(i,m)} \mu (d)\left \lfloor \frac{min(i,m)}{d}  \right \rfloor<br>\&amp;&#x3D;\sum\limits_{d&#x3D;1}^{min(n,m)} \mu (d)\left \lfloor \frac{n}{d}  \right \rfloor \left \lfloor \frac{m}{d}  \right \rfloor<br>\end{aligned}$$</p><h2 id="费马小定理-欧拉定理-扩展欧拉定理"><a href="#费马小定理-欧拉定理-扩展欧拉定理" class="headerlink" title="费马小定理&amp;欧拉定理&amp;扩展欧拉定理"></a>费马小定理&amp;欧拉定理&amp;扩展欧拉定理</h2><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>如果</p><p>$$ d|(a-b) $$</p><p>则我们称</p><p>$$ a\equiv b\pmod{d}$$</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>1.反身性：$a\equiv a \pmod{m}$；</p><p>2.对称性：若 $a\equiv b \pmod{m}$，则 $b\equiv a \pmod{m}$；</p><p>3.传递性：若 $a\equiv b \pmod{m}$，$b\equiv c \pmod{m}$，则 $a\equiv c \pmod{m}$；</p><p>4.同余式相加：若 $a\equiv b \pmod{m}$，$c\equiv d \pmod{m}$，则 $a\pm c\equiv b\pm d \pmod{m}$；</p><p>5.同余式相乘：若 $a\equiv b \pmod{m}$，$c\equiv d \pmod{m}$，则$ac\equiv bd \pmod{m}$。</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>对于一个整数 $a$ 和 质数 $p$，如果满足</p><p>$$a\perp p$$</p><p>则符合</p><p>$$a^{p-1}\equiv 1 \pmod{p}$$</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>费马小定理的广义。</p><p>对于两个整数 $a$ 和 $m$，如果满足</p><p>$$a\perp m$$</p><p>则符合</p><p>$$a^{\varphi(m)}\equiv 1\pmod{m}$$</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>若</p><p>$$ ab\equiv 1\bmod m $$</p><p>则 </p><p>$b$ 为 $a$ 在 $\bmod m$ 意义下的逆元，同时，$a$ 也为 $b$ 在 $\bmod m$ 意义下的逆元。</p><p>任意整数 $a$ 在 $\bmod m$ 意义下的逆元记为 $inv(a,m)$。</p><p>显然，逆元就是在 $\bmod$ 某个数意义下的倒数，即</p><p>$$ inv(a,m)&#x3D;a^{-1} \bmod m$$</p><h4 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h4><ol><li>费马小定理求法（$p\in Prime,a\perp p$）</li></ol><p>$$\begin{aligned}<br>\&amp;\because a^{p-1}\equiv 1 \pmod{p}<br>\&amp;\therefore a^{p-2}&#x3D;\frac {1}{a}\pmod{p}<br>\&amp;\therefore inv(a,p)&#x3D;a^{p-2}\pmod{p}<br>\end{aligned}$$</p><ol start="2"><li>欧拉定理求法（$a\perp m$）</li></ol><p>$$\begin{aligned}<br>\&amp;\because a^{\varphi(m)}\equiv 1 \pmod{m}<br>\&amp;\therefore a^{\varphi(m)-1}&#x3D;\frac {1}{a}\pmod{m}<br>\&amp;\therefore inv(a,p)&#x3D;a^{\varphi(m)-1}\pmod{m}<br>\end{aligned}$$</p><ol start="3"><li>线性求逆元（$p\in Prime,a\perp p$）</li></ol><p>对于所有的 $i&lt;p$，有一种线性求逆元（$i^{-1}$）的方法。</p><p>因为 $i&lt;p$，所以可以用 $i$ 表示 $p$，即</p><p>$$ p&#x3D;ki+b $$</p><p>即</p><p>$$ ik+b \equiv 0 \pmod{p} $$</p><p>等式两边同乘 $i^{-1}$，得</p><p>$$ k+bi^{-1} \equiv 0 \pmod{p} $$</p><p>移项，分离处 $i^{-1}$，得</p><p>$$ i^{-1} \equiv -kb^{-1} \pmod{p} $$</p><p>又</p><p>$$ \begin{aligned}<br>\&amp;\because k&#x3D;\left \lfloor p&#x2F;i \right \rfloor,b&#x3D;p\bmod i<br>\&amp;\therefore i^{-1} \equiv -(p&#x2F;i)(p\bmod i)^{-1} \pmod{p}<br>\&amp;\therefore i^{-1} \equiv (p-p&#x2F;i)(p\bmod i)^{-1} \pmod{p}<br>\end{aligned} $$</p><p>因为 $(p\bmod i)^{-1}$ 已经处理好了</p><p>所以可以线性处理</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br></pre></td></tr></table></figure><ol start="4"><li>线性求阶乘逆元</li></ol><p>可以在组合数问题上发挥作用</p><p>显然</p><p>$$\frac{1}{(n-1)!}&#x3D;n\cdot \frac{1}{n!}$$</p><p>所以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">inv[n]=<span class="built_in">ksm</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br></pre></td></tr></table></figure><h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>$$a^b\equiv<br>\begin{cases}<br>a^{b\mod{\varphi(m)}}&amp;a\perp m<br>\a^b&amp;\neg a\perp m,b&lt;\varphi (m)<br>\a^{b\mod{\varphi (m)} +\varphi (m)}&amp;\neg a\perp m,b\geq\varphi(m)<br>\end{cases}<br>\mod{m}$$</p><p>互质可以不要</p><p>$$ a^b \equiv \begin{cases} a^b&amp;b&lt;\varphi (m)\a^{b\mod{\varphi (m)} +\varphi (m)}&amp;b\geq\varphi (m)\end{cases}\mod{m}$$</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
